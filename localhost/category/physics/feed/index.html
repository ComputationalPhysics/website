<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Physics &#8211; Computational Physics</title>
	<atom:link href="category/physics/feed/" rel="self" type="application/rss+xml" />
	<link>http://localhost</link>
	<description>Exploring physics beyond what can be counted by hand</description>
	<lastBuildDate>Sun, 21 Feb 2016 11:16:19 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.7</generator>
	<item>
		<title>LaTeX package for UiO Master&#8217;s theses</title>
		<link>2014/08/04/latex-package-for-uio-masters-theses/</link>
		<comments>2014/08/04/latex-package-for-uio-masters-theses/#respond</comments>
		<pubDate>Mon, 04 Aug 2014 11:19:45 +0000</pubDate>
		<dc:creator><![CDATA[Svenn-Arne Dragly]]></dc:creator>
				<category><![CDATA[LaTeX]]></category>
		<category><![CDATA[Physics]]></category>
		<category><![CDATA[computational]]></category>
		<category><![CDATA[documentclass]]></category>
		<category><![CDATA[master]]></category>
		<category><![CDATA[master's]]></category>
		<category><![CDATA[package]]></category>
		<category><![CDATA[physics]]></category>
		<category><![CDATA[thesis]]></category>
		<category><![CDATA[uiofysmaster]]></category>

		<guid isPermaLink="false">?p=799</guid>
		<description><![CDATA[A couple of fellow Computational Physics students and I have developed a LaTeX package for Master&#8217;s theses at the University of Oslo. It is tailored for physics, but should be useful for other students as well. If you are about to start writing your thesis and need a package to provide a proper front page, [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>A couple of fellow Computational Physics students and I have developed a LaTeX package for Master&#8217;s theses at the University of Oslo. It is tailored for physics, but should be useful for other students as well. If you are about to start writing your thesis and need a package to provide a proper front page, formatting, code highlighting, and more, you should check it out.</p>
<p><a href="https://github.com/ComputationalPhysics/uiofysmaster/">The package and instructions on how to install it is located here</a>.</p>
]]></content:encoded>
			<wfw:commentRss>2014/08/04/latex-package-for-uio-masters-theses/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Quantum molecular dynamics simulation of $H_2$ &#038; $H_2 O$</title>
		<link>2013/11/22/quantum-molecular-dynamics-simulation-of-h_2-h_2-o/</link>
		<comments>2013/11/22/quantum-molecular-dynamics-simulation-of-h_2-h_2-o/#respond</comments>
		<pubDate>Fri, 22 Nov 2013 16:58:40 +0000</pubDate>
		<dc:creator><![CDATA[Milad Mobarhan]]></dc:creator>
				<category><![CDATA[atoms]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Computational Physics]]></category>
		<category><![CDATA[molecular dynamics]]></category>
		<category><![CDATA[molecules]]></category>
		<category><![CDATA[ovito]]></category>
		<category><![CDATA[Physics]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">?p=574</guid>
		<description><![CDATA[The classical molecular dynamics is primarily based on classical motion of atoms interacting with a given potential.  Quantum molecular dynamics, on the other hand, focuses on all the interactions between atoms and electrons, and does not involve fitting interactions to experimental data.  An approach to include the electronic structure is to solve the electronic Schrödinger [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>The classical molecular dynamics is primarily based on classical motion of atoms interacting with a given potential.  Quantum molecular dynamics, on the other hand, focuses on all the interactions between atoms and electrons, and does not involve fitting interactions to experimental data.  An approach to include the electronic structure is to solve the electronic Schrödinger equation, given the set of fixed nuclear positions, in each molecular dynamics step and let the nuclei to move according to classical mechanics in an effective potential due to the electrons.</p>
<p>In the last two weeks I have been working on calculating this effective  potential, based on the results from my Hartree-Fock code.  The forces acting on the nuclei are found by taking the gradient of the energy with respect to the nuclei positions. Below I have included  molecular dynamics simulation of $H_2$  and $H_2O$ molecule, where the effective potential is calculated in each time step.</p>
<p><iframe class='youtube-player' type='text/html' width='625' height='382' src='http://www.youtube.com/embed/fLs1nCLNv3c?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<p><iframe class='youtube-player' type='text/html' width='625' height='382' src='http://www.youtube.com/embed/2QCJa-GghmQ?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
]]></content:encoded>
			<wfw:commentRss>2013/11/22/quantum-molecular-dynamics-simulation-of-h_2-h_2-o/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Symmetries in one-body and two-body matrix elements in Hartree-Fock</title>
		<link>2013/11/19/symmetries-in-one-body-and-two-body-matrix-elements-in-hartree-fock/</link>
		<comments>2013/11/19/symmetries-in-one-body-and-two-body-matrix-elements-in-hartree-fock/#respond</comments>
		<pubDate>Tue, 19 Nov 2013 20:43:25 +0000</pubDate>
		<dc:creator><![CDATA[Milad Mobarhan]]></dc:creator>
				<category><![CDATA[Computational Physics]]></category>
		<category><![CDATA[Efficiency]]></category>
		<category><![CDATA[molecules]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[Physics]]></category>

		<guid isPermaLink="false">?p=535</guid>
		<description><![CDATA[As a part of my master project, I have lately  been working on  developing a Hartree-Fock (HF) code for atomic and molecular systems.   The Hartree-Fock method is the simplest many-body theory and a central starting point for most methods that describe the many-electron system more accurately. One of the advantages of HF is its low [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>As a part of my master project, I have lately  been working on  developing a Hartree-Fock (HF) code for atomic and molecular systems.   The Hartree-Fock method is the simplest many-body theory and a central starting point for most methods that describe the many-electron system more accurately. One of the advantages of HF is its low computational cost compare to more sophisticated techniques, which makes it attractive for quantum molecular dynamics studies.</p>
<p>Our HF code is based on gaussian basis sets, which makes the integral evaluations much easier and gives a huge computational saving.  However, by taking into account the symmetries in one-body and two-body integrals, the computational cost can be reduced even further.  Since the basis functions and matrix elements  are real, we have the following symmetries</p>
<p>$$\langle i |\hat{h}|j \rangle = \langle j |\hat{h}|i \rangle $$</p>
<p>and</p>
<p>$$\langle i k|jl \rangle = \langle jk |il \rangle =  \langle il |jk \rangle = \langle jl |ik \rangle =\langle ki |lj \rangle = \langle li |kj \rangle = \langle kj| li \rangle=  \langle lj |ki \rangle $$</p>
<p>for one-body and two-body matrix elements, respectively. Having implemented these symmetries, the computation time for  the ground state energy for a single water molecule (using 4-31G basis set) went from 6 sec to 1 sec, which is a huge speed up! For more details please check out this <a href="http://theoretical-physics.net/dev/src/quantum/hf.html">site</a>.</p>
]]></content:encoded>
			<wfw:commentRss>2013/11/19/symmetries-in-one-body-and-two-body-matrix-elements-in-hartree-fock/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Working with percolation clusters in Python</title>
		<link>2013/03/25/working-with-percolation-clusters-in-python/</link>
		<pubDate>Mon, 25 Mar 2013 12:38:12 +0000</pubDate>
		<dc:creator><![CDATA[Svenn-Arne Dragly]]></dc:creator>
				<category><![CDATA[Computational Physics]]></category>
		<category><![CDATA[Featured]]></category>
		<category><![CDATA[Physics]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[Python]]></category>
		<category><![CDATA[clusters]]></category>
		<category><![CDATA[matlab]]></category>
		<category><![CDATA[measurements]]></category>
		<category><![CDATA[percolation]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[scipy]]></category>

		<guid isPermaLink="false">?p=305</guid>
		<description><![CDATA[We&#8217;re working on a new project in FYS4460 about percolation. In the introduction of this project, we are given a few commands to help us demonstrate a few properties of percolation clusters using MATLAB. As the Python-fan I am, I of course had to see if I could find equivalent commands in Python, and thankfully [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>We&#8217;re working on a new project in FYS4460 about percolation. In the introduction of this project, we are given a few commands to help us demonstrate a few properties of percolation clusters using MATLAB.</p>
<p>As the Python-fan I am, I of course had to see if I could find equivalent commands in Python, and thankfully that was quite easy. Below I will summarize the commands that will generate a random matrix of filled and unfilled areas, label each cluster in this matrix and calculate the area of each such cluster. Finally, we&#8217;ll draw a bounding box around the largest cluster.</p>
<p><span id="more-305"></span></p>
<p>First of all, we need to include the <strong>pylab</strong> package together with the <strong>scipy.ndimage.measurements</strong> package:</p>
<pre class="brush:py">from pylab import *
from scipy.ndimage import measurements</pre>
<p>Now, let&#8217;s create a random matrix of filled and unfilled regions and visualize it:</p>
<pre class="brush:py">L = 100
r = rand(L,L)
p = 0.4
z = r &lt; p

imshow(z, origin='lower', interpolation='nearest')
colorbar()
title("Matrix")
show()</pre>
<p>This creates a matrix of random numbers <strong>r</strong> before creating a map <strong>z</strong> of this matrix where each element is set to True if <strong>r</strong> &lt; p and False if <strong>r</strong> &gt; p:</p>
<div id="attachment_852" style="width: 310px" class="wp-caption aligncenter"><a href="http://dragly.org/wp-content/uploads/2013/03/matrix.png" rel="lightbox[305]"><img class="size-medium wp-image-852" alt="Visualization of the map z." src="http://dragly.org/wp-content/uploads/2013/03/matrix-300x225.png" width="300" height="225" /></a><p class="wp-caption-text">Visualization of the map z.</p></div>
<p>Furthermore we want to label each cluster. This is performed by the scipy.ndimage.measurements.label function:</p>
<pre class="brush:py">lw, num = measurements.label(z)
imshow(lw, origin='lower', interpolation='nearest')
colorbar()
title("Labeled clusters")
show()</pre>
<p>This labels each cluster with a number which may be visualized using the imshow function as above:</p>
<div id="attachment_872" style="width: 310px" class="wp-caption aligncenter"><a href="http://dragly.org/wp-content/uploads/2013/03/labeled-matrix-ordered.png" rel="lightbox[305]"><img class="size-medium wp-image-872" alt="Matrix with labeled clusters, so it is a bit hard to distinguish each cluster." src="http://dragly.org/wp-content/uploads/2013/03/labeled-matrix-ordered-300x225.png" width="300" height="225" /></a><p class="wp-caption-text">Matrix with labeled clusters, so it is a bit hard to distinguish each cluster.</p></div>
<p>Beacause the label starts from the bottom up, the cluster colors are a bit too ordered, making it hard to distinguish two clusters close to each other. To fix this, we may shuffle the labeling with the following code:</p>
<pre class="brush:py">b = arange(lw.max() + 1)
shuffle(b)
shuffledLw = b[lw]
imshow(shuffledLw, origin='lower', interpolation='nearest')
colorbar()
title("Labeled clusters")
show()</pre>
<p>Now it is way easier to see the different clusters:</p>
<div id="attachment_871" style="width: 310px" class="wp-caption aligncenter"><a href="http://dragly.org/wp-content/uploads/2013/03/labeled-matrix.png" rel="lightbox[305]"><img class="size-medium wp-image-871" alt="The same matrix with all clusters labeled with a number." src="http://dragly.org/wp-content/uploads/2013/03/labeled-matrix-300x225.png" width="300" height="225" /></a><p class="wp-caption-text">The same matrix with all clusters labeled with a number.</p></div>
<p>After this we may want to extract some properties of the clusters, such as the area. This is possible using the scipy.ndimage.measurements.sum function:</p>
<pre class="brush:py">area = measurements.sum(z, lw, index=arange(lw.max() + 1))
areaImg = area[lw]
im3 = imshow(areaImg, origin='lower', interpolation='nearest')
colorbar()
title("Clusters by area")
show()</pre>
<p>The above code now plots the same matrix as above, but this time with all clusters colored by area:</p>
<div id="attachment_873" style="width: 310px" class="wp-caption aligncenter"><a href="http://dragly.org/wp-content/uploads/2013/03/colored-by-area.png" rel="lightbox[305]"><img class="size-medium wp-image-873" alt="Matrix with the clusters colored by area." src="http://dragly.org/wp-content/uploads/2013/03/colored-by-area-300x225.png" width="300" height="225" /></a><p class="wp-caption-text">Matrix with the clusters colored by area.</p></div>
<p>Finally, we may want to find the bounding box of the largest cluster, so we again may see if there is a path from one side to the other. This is possible by using the function scipy.ndimage.measurements.find_objects. Note however that this is a bit risky. If there are two clusters that are largest with the same area, find_objects will find the bounding box of both clusters. I&#8217;ll leave it up to you to figure out a method to avoid this if necessary. (Pro tip: Make a mapping of the cluster labels to the areas.)</p>
<p>With the find_objects function, we are able to plot a rectangle around the largest cluster:</p>
<pre class="brush:py">sliced = measurements.find_objects(areaImg == areaImg.max())
if(len(sliced) &gt; 0):
    sliceX = sliced[0][1]
    sliceY = sliced[0][0]
    plotxlim=im3.axes.get_xlim()
    plotylim=im3.axes.get_ylim()
    plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \
                      [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \
                      color="red")
    xlim(plotxlim)
    ylim(plotylim)

show()</pre>
<p>This shows up like this:</p>
<div id="attachment_874" style="width: 310px" class="wp-caption aligncenter"><a href="http://dragly.org/wp-content/uploads/2013/03/bounding-box.png" rel="lightbox[305]"><img class="size-medium wp-image-874" alt="bounding-box" src="http://dragly.org/wp-content/uploads/2013/03/bounding-box-300x225.png" width="300" height="225" /></a><p class="wp-caption-text">A bounding box on top of the largest cluster. The rest are colored by area.</p></div>
<p>The whole program then becomes as follows:</p>
<pre class="brush:py">from pylab import *
from scipy.ndimage import measurements

L = 100
r = rand(L,L)
p = 0.4
z = r&lt;p

figure(figsize=(16,5))
subplot(1,3,1)
imshow(z, origin='lower', interpolation='nearest')
colorbar()
title("Matrix")

# Show image of labeled clusters (shuffled)
lw, num = measurements.label(z)
subplot(1,3,2)
b = arange(lw.max() + 1) # create an array of values from 0 to lw.max() + 1
shuffle(b) # shuffle this array
shuffledLw = b[lw] # replace all values with values from b
imshow(shuffledLw, origin='lower', interpolation='nearest') # show image clusters as labeled by a shuffled lw
colorbar()
title("Labeled clusters")

# Calculate areas
subplot(1,3,3)
area = measurements.sum(z, lw, index=arange(lw.max() + 1))
areaImg = area[lw]
im3 = imshow(areaImg, origin='lower', interpolation='nearest')
colorbar()
title("Clusters by area")

# Bounding box
sliced = measurements.find_objects(areaImg == areaImg.max())
if(len(sliced) &gt; 0):
    sliceX = sliced[0][1]
    sliceY = sliced[0][0]
    plotxlim=im3.axes.get_xlim()
    plotylim=im3.axes.get_ylim()
    plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \
                      [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \
                      color="red")
    xlim(plotxlim)
    ylim(plotylim)

show()</pre>
]]></content:encoded>
			</item>
		<item>
		<title>Optimizing your C++ code for molecular dynamics</title>
		<link>2013/03/19/optimizing-your-c-code-for-molecular-dynamics/</link>
		<pubDate>Tue, 19 Mar 2013 18:10:18 +0000</pubDate>
		<dc:creator><![CDATA[Svenn-Arne Dragly]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[code]]></category>
		<category><![CDATA[Computational Physics]]></category>
		<category><![CDATA[const]]></category>
		<category><![CDATA[Efficiency]]></category>
		<category><![CDATA[efficient]]></category>
		<category><![CDATA[fast]]></category>
		<category><![CDATA[molecular dynamics]]></category>
		<category><![CDATA[optimizing]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[Physics]]></category>
		<category><![CDATA[pointers]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[quick]]></category>
		<category><![CDATA[references]]></category>

		<guid isPermaLink="false">http://dragly.org/?p=843</guid>
		<description><![CDATA[While working with the molecular dynamics project in FYS4460 I decided to learn more about how to optimize my C++ code for performance. As always, I follow Donald Knuth&#8217;s famous quote as a guideline to optimization: &#8220;We should forget about &#8230; <a href="http://dragly.org/2013/03/19/optimizing-your-c-code-for-molecular-dynamics/">Continue reading <span>&#8594;</span></a>
]]></description>
				<content:encoded><![CDATA[<p>While working with the molecular dynamics project in <a href="http://www.uio.no/studier/emner/matnat/fys/FYS4460/v13/">FYS4460</a> I decided to learn more about how to optimize my C++ code for performance. As always, I follow Donald Knuth’s famous quote as a guideline to optimization:</p>
<blockquote><p>“We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil”<sup id="cite_ref-autogenerated268_2-0"><a href="http://en.wikipedia.org/wiki/Program_optimization#cite_note-autogenerated268-2">[2]</a></sup></p></blockquote>
<p>And this has proved to be as true as ever in my efforts to optimize my code. There are a bunch of things that I have tried that didn’t turn out to be as effective as I had thought, and some other that I would never think could be so important. I’ve listed most of these in this post so you too may learn from my experience. They are all listed in the order from most useful to most wasteful:</p>
<p><span id="more-281"></span></p>
<h2>Benchmark!</h2>
<p>Before doing any “optimization”, benchmark your code by using a timer (MPI has a timer in their library, as does Boost::MPI). Otherwise you might be optimizing and rewrite already working code for no good reason. You should always measure and see if your optimizations are good for anything. If they are not, you should consider leaving things as they are for the sake of readability or style.</p>
<h2>Analyze your code using a tool such as Qt Creator (and Valgrind)</h2>
<p>Qt Creator has a really neat visualization tool for the Valgrind profiler. This visualization is very helpful to figure out what parts of your application is actually wasting time.</p>
<div class="wp-caption aligncenter" id="attachment_845" style="width: 650px;"><a href="http://dragly.org/wp-content/uploads/2013/03/qt-valgrind.png" rel="lightbox[843]"><img class="size-large wp-image-845" alt="Qt's Valgrind visualization is very neat to see what parts of your code that are spending the most time." src="http://dragly.org/wp-content/uploads/2013/03/qt-valgrind-755x600.png" width="640" height="508" /></a></p>
<p class="wp-caption-text">Qt’s Valgrind visualization is very neat to see what parts of your code that are spending the most time.</p>
</div>
<p>Here you may see the number of instruction calls each functions makes use of. This helps greatly in pinpointing the bottlenecks of you code.</p>
<p>You can read more about Qt and Valgrind <a href="http://qt-project.org/doc/qtcreator-2.6/creator-cache-profiler.html">on their webpages</a>.</p>
<h2>Use const references (or pointers) whenever possible</h2>
<p>Whenever you are declaring a function or a variable, you should most likely use const references all over the place. References keeps your code from making unnecessary copies while the const keeps you from making changes to things that should be constant. Just don’t return references of temporary objects!</p>
<p>In practice you should change your getter function declarations (and implementations) from</p>
<pre class="brush:cpp">Vector3 Atom::position();</pre>
<p>to</p>
<pre class="brush:cpp">const Vector3&amp; Atom::position();</pre>
<p>But only do this when the object you return is a class member. Such as the position is for the Atom. If you return av temporary you must by all means return a copy. However, you may let the parameter be a reference.</p>
<pre class="brush:cpp">Vector3 Atom::vectorTo(const Atom&amp; otherAtom) {
    Vector3 vector = otherAtom.position() - this-&gt;position();
    return vector;
}</pre>
<p>Note the ampersand (&amp;) which tells the compiler that you wish to return a reference declaration. Whenever this is left out, the compiler will think that you want to make a copy of the object, which can be very expensive performance wise.</p>
<p>If you are using pointers, you don’t have to worry about this. You should go back to worrying about allocating memory instead.</p>
<h2>Write components of 3D vectors explicitly in your force calculation</h2>
<p>The following code may look nasty in comparison to for instance using a vector class with overloaded + and = operators, but it is much faster:</p>
<pre class="brush:cpp">double x;
double y;
double z;
x = atom2-&gt;position()(0) + atom2Offset(0) - atom1-&gt;position()(0);
y = atom2-&gt;position()(1) + atom2Offset(1) - atom1-&gt;position()(1);
z = atom2-&gt;position()(2) + atom2Offset(2) - atom1-&gt;position()(2);
rSquared = x*x + y*y + z*z;</pre>
<p>This is generally true, but more so if you are using a general vector class and not an optimized 3D vector class. Optimized 3D vector classes will be only a bit faster.</p>
<h2>Inline your much-used getters and setters</h2>
<p>If you are using getters and setters like</p>
<pre class="brush:cpp">const Vector3&amp; Atom::position() const { 
    return m_position; 
}</pre>
<p>you may want to inline these in the header file. Ideally you should declare the header as usual and put the implementation with the inline keyword in the same header file:</p>
<pre class="brush:cpp">class Atom
{
public:
    inline const Vector3 &amp;position() const;
protected:
    Vector3 m_position;
}

inline const Vector3 &amp;Atom::position() const
{
    return m_position;
}</pre>
<p>Did you notice the extra const at the end of the declaration? This is just good style telling the compiler that this function will not write to the Atom object, only read from it. Again, this is good style, but not necessary.</p>
<h2>Use double arrays instead of classes to store positions and forces</h2>
<p>I’m not doing this myself, but after some intense optimization testing i found that for the Lennard-Jones force, the code runs in about 67 % of the original time by storing the positions and forces in their own continuous-memory arrays rather than in Atom objects.</p>
<p>This is optimal because (for my code at least) it caused the processor to keep data in the <a href="http://en.wikipedia.org/wiki/CPU_cache">CPU cache</a> over longer time, which is faster than having to fetch new data from RAM. The reason is likely that it can prefetch the position data more easily when it is stored sequentially rather than together with other data in the Atom object.</p>
<p>This may differ greatly from architecture to architecture, so I skipped actually implementing this myself. The code became so much harder to maintain with this optimization built in that I eventually left it out. In addition, I have no idea how it would fare with 3- or 6-particle forces which are yet to be implemented.</p>
<p>If you store everything in double arrays already I would also advice you to consider storing it in static-size memory on the stack rather than allocating the memory dynamically. I hear that this is also supposed to improve performance.</p>
]]></content:encoded>
			</item>
		<item>
		<title>Getting the latest version of Ovito for Ubuntu</title>
		<link>2013/02/28/getting-the-latest-version-of-ovito-for-ubuntu/</link>
		<pubDate>Thu, 28 Feb 2013 10:09:22 +0000</pubDate>
		<dc:creator><![CDATA[Svenn-Arne Dragly]]></dc:creator>
				<category><![CDATA[atoms]]></category>
		<category><![CDATA[Computational Physics]]></category>
		<category><![CDATA[Featured]]></category>
		<category><![CDATA[molecular dynamics]]></category>
		<category><![CDATA[molecules]]></category>
		<category><![CDATA[ovito]]></category>
		<category><![CDATA[Physics]]></category>
		<category><![CDATA[Ubuntu]]></category>
		<category><![CDATA[visualization]]></category>
		<category><![CDATA[vmd]]></category>

		<guid isPermaLink="false">http://dragly.org/?p=831</guid>
		<description><![CDATA[Ovito is a great tool to visualize atoms from molecular dynamics simulations and to perform some statistical analysis on the data. The tool is an alternative to other similar tools such as VMD and ParaView. The current version of Ovito &#8230; <a href="http://dragly.org/2013/02/28/getting-the-latest-version-of-ovito-for-ubuntu/">Continue reading <span>&#8594;</span></a>
]]></description>
				<content:encoded><![CDATA[<p>Ovito is a great tool to visualize atoms from molecular dynamics simulations and to perform some statistical analysis on the data. The tool is an alternative to other similar tools such as VMD and ParaView.</p>
<p>The current version of Ovito in the Ubuntu repositories (version 0.9.2) is sadly very outdated. Even though you of course may download the latest version from Ovito&#8217;s webpages and install it locally in your home folder, I often find it better to get a newer package version.</p>
<p>At the Computational Physics group&#8217;s PPA I have now uploaded the latest build of Ovito for Ubuntu in a package that will automatically replace the current Ovito version. Note that this is not a release version of Ovito, but the latest version fetched from Ovito&#8217;s sources (currently nicknamed 1.1.1.90). The reason is that Ovito&#8217;s creator, Alexander Stukowski, was kind enough to implement a suggestion we proposed to change the default input handler for the viewports to be the orbit input handler. This behavior feels so much more natural and makes the already great Ovito application even better.</p>
<p>To install the latest version of Ovito, all you need to do is to open up a terminal and type these lines:</p>
<pre class="brush:shell">sudo apt-add-repository ppa:comp-phys/stable
sudo apt-get update
sudo apt-get install ovito</pre>
<p>Note that the Computational Physics repository also contains newer versions of the Armadillo package, which will automatically be updated if you do not remove the repository after installing Ovito.</p>
]]></content:encoded>
			</item>
	</channel>
</rss>
