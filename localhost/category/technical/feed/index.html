<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Technical &#8211; Computational Physics</title>
	<atom:link href="category/technical/feed/" rel="self" type="application/rss+xml" />
	<link>http://localhost</link>
	<description>Exploring physics beyond what can be counted by hand</description>
	<lastBuildDate>Sun, 21 Feb 2016 11:16:19 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.7</generator>
	<item>
		<title>Choosing the right license for your code</title>
		<link>2014/11/22/choosing-the-right-license-for-your-code/</link>
		<pubDate>Sat, 22 Nov 2014 15:02:00 +0000</pubDate>
		<dc:creator><![CDATA[Svenn-Arne Dragly]]></dc:creator>
				<category><![CDATA[Computational Physics]]></category>
		<category><![CDATA[Copyleft]]></category>
		<category><![CDATA[Technical]]></category>
		<category><![CDATA[bsd]]></category>
		<category><![CDATA[copyleft]]></category>
		<category><![CDATA[copyright]]></category>
		<category><![CDATA[gpl]]></category>
		<category><![CDATA[john hunter]]></category>
		<category><![CDATA[license]]></category>
		<category><![CDATA[licenses]]></category>
		<category><![CDATA[licensing]]></category>
		<category><![CDATA[open source]]></category>
		<category><![CDATA[richard stallman]]></category>

		<guid isPermaLink="false">?p=851</guid>
		<description><![CDATA[I was pointed to John Hunter&#8217;s Why we should be using BSD and came to think about how I rather tend to advocate using the GPL license. Richard Stallman makes some very convincing arguments for why GPL is the better choice, but even though I like this reasoning, I do see why choosing a different [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>I was pointed to John Hunter&#8217;s <em><a href="http://nipy.sourceforge.net/nipy/devel/faq/johns_bsd_pitch.html">Why we should be using BSD</a></em> and came to think about how I rather tend to advocate using the GPL license. <a href="http://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman </a>makes some very convincing arguments for <a href="http://www.gnu.org/licenses/why-not-lgpl.html">why GPL is the better choice</a>, but even though I like this reasoning, I do see why choosing a different license may be the right choice.</p>
<p>In this post, I will explain some of the differences between <a href="http://en.wikipedia.org/wiki/BSD_licenses">BSD</a> and <a href="http://www.gnu.org/copyleft/gpl.html">GPL</a> and hopefully help you to choose for yourself. The target audience for this post are people in the scientific community, but it may also be useful to others.</p>
<p>So how do BSD and GPL differ? Below I have listed what I think is most important, but please remember that I am not a lawyer, and that there are other effects of licensing that may apply to you:</p>
<ul>
<li>BSD is a free-for-all license that only requires attribution. Anyone using your code must give credit to you as the original author. Apart from that, they can do pretty much everything. They can change the code and sell programs based on it without asking you.</li>
<li>GPL too requires attribution. However, it also requires anyone distributing software based on your source code to make available any changes they make to it. They can still sell programs based on your code to others without asking, but if they were to do something really smart with your code, you can demand that they share the changes with you. And you too can sell software based on their changes.</li>
</ul>
<p>Before moving on, I would like to clarify one important thing: Even though you are licensing your code as BSD or GPL, you can still sell software based on your code. You can even sell the rights to use your code with a different license. The licenses only apply to what other people can do with your code. You still keep all other rights.</p>
<p>In the below table, I have summarized the differences between the licenses by listing a few scenarios. &#8220;They&#8221; is referring to someone using your code in their own software projects:</p>
<table>
<tbody>
<tr>
<td></td>
<td><strong>BSD</strong></td>
<td><strong>GPL</strong></td>
</tr>
<tr>
<td>You can sell software based on your own code.</td>
<td><span style="color: #339966;">✔  </span></td>
<td><span style="color: #339966;">✔  </span></td>
</tr>
<tr>
<td>They can sell software based on your code.</td>
<td><span style="color: #339966;">✔  </span></td>
<td><span style="color: #339966;">✔  </span></td>
</tr>
<tr>
<td>They can make changes to your code.</td>
<td><span style="color: #339966;">✔ </span></td>
<td><span style="color: #339966;">✔  </span></td>
</tr>
<tr>
<td>They have to give you credit for writing the original code.</td>
<td><span style="color: #339966;">✔  </span></td>
<td><span style="color: #339966;">✔ </span></td>
</tr>
<tr>
<td>They have to use the same license as you.</td>
<td><span style="color: #800000;">✖ </span></td>
<td><span style="color: #339966;">✔ </span></td>
</tr>
<tr>
<td>You can demand access to the changes they made to your code.</td>
<td><span style="color: #800000;">✖</span></td>
<td><span style="color: #339966;">✔ </span></td>
</tr>
<tr>
<td>They can sell software based on your code without sharing their changes with you.</td>
<td><span style="color: #339966;">✔ </span></td>
<td><span style="color: #800000;">✖</span></td>
</tr>
<tr>
<td>You can sell software based on the changes they made to your code.</td>
<td><span style="color: #800000;">✖</span> *</td>
<td><span style="color: #339966;">✔ </span></td>
</tr>
</tbody>
</table>
<p><em>*Except if they also use a BSD license for their changes.</em></p>
<p>Some people call GPL &#8220;viral&#8221; because it &#8220;infects&#8221; any software using GPL licensed code. Any project using code with a GPL license will basically have to be GPL licensed too. This may be a showstopper for some companies that want to keep their own changes proprietary (secret/hidden) while still using your code. Note that this only applies if they distribute the software to others: If someone downloads your code and plays around with it on their own computer, they don&#8217;t have to care about the GPL license.</p>
<p>The viral effect is why Richard Stallman advocates the GPL license. He thinks that it benefits the open source community (and perhaps also the scientific community) that software using GPL code must be GPL too. In his opinion, companies have money to spend on developing new products or to buy access to other people&#8217;s source code. The open source community, on the other hand, does not necessarily have the same monetary resources, but has access to all the open source code out there. If an open source project is fine with the adhering to the GPL license, they can also use all other GPL licensed code .</p>
<p>Further, I think you should choose GPL for any code you think might be commercially viable <em>for yourself</em> in the future. Some people think the best option is to keep source code proprietary if you want to make money of it in the future. I think the exact opposite. If you are working on a project that you believe has some commercial value, why not let others find that commercial value for you? If someone starts selling software based on an improved version of your code, you can demand that they share the changes with you and start selling the software yourself.</p>
<p>However, there are many good arguments for using the BSD license too. Many open source projects are working with companies that require code not to be GPL licensed. One such project is <a href="http://matplotlib.org/">Matplotlib</a>, for which John Hunter is the original author. They have received contributions from companies like <a href="http://enthought.com">Enthought</a>, which want to make sure they don&#8217;t have to license all their software as GPL because some code they use is from GPL projects. Such contributions are often significant for open source projects, and I can see why choosing BSD is a good middle way for them to keep the project open while still getting as much benefit from cooperation with companies.</p>
<p>Some also argue that BSD attracts more developers than GPL because some developers may be put off by a GPL license. However, I believe this works both ways. Some developers are also put off by non-GPL projects. I don&#8217;t think your licensing choice will change much in the number of developers that are attracted to your project. If anything, I would do some research and contact relevant companies and developers and ask if they would be willing to contribute to your project. You can always change the license as you go, but you should know that all code that has already been licensed as GPL or BSD will forever be licensed that way. It is non-retractable. Any future changes you make to your own code, however, can be put under a different license. You may even choose not to license your new code any more if you want to.</p>
<p>To conclude, when choosing between BSD and GPL, you should consider whether your main goal is to contribute to the open source community or to everyone in general. If you target only the open source community, GPL may be your best choice. If you want to contribute to everyone without further restrictions to the usage of your code, BSD may be your best bet.</p>
<p>Personally, I will continue using GPL as long as I think my code may turn into a commercially viable project or if I just don&#8217;t have a long-term plan yet. However, I will happily use BSD if I think the code can be contributed into a BSD licensed project such as Matplotlib.</p>
<p>There are also many other licenses out there. Have a look at the list made by the <a href="http://opensource.org/licenses">Open Source Initiative</a> if you want to know more about other licenses.</p>
]]></content:encoded>
			</item>
		<item>
		<title>New project structure for projects in Qt Creator with unit tests</title>
		<link>2014/03/13/new-project-structure-for-projects-in-qt-creator-with-unit-tests/</link>
		<pubDate>Thu, 13 Mar 2014 15:26:21 +0000</pubDate>
		<dc:creator><![CDATA[Svenn-Arne Dragly]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[Qt]]></category>
		<category><![CDATA[Technical]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[.pri]]></category>
		<category><![CDATA[.pro]]></category>
		<category><![CDATA[project]]></category>
		<category><![CDATA[project files]]></category>
		<category><![CDATA[qmake]]></category>
		<category><![CDATA[qt]]></category>
		<category><![CDATA[structure]]></category>

		<guid isPermaLink="false">?p=692</guid>
		<description><![CDATA[Note: This is a new version of an earlier post, with a revised project structure. Note 2: See this post for the same project structure using the even better Catch testing framework. This post assumes that you are using a C++ testing framework such as UnitTest++. See this earlier post for some information on installing [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><em><strong>Note:</strong> This is a new version of <a href="http://dragly.org/2013/04/19/setting-up-unittest-with-qt-creator/">an earlier post</a>, with a revised project structure.</em></p>
<p><em><strong>Note 2:</strong> See <a href="http://dragly.org/2015/11/24/getting-started-with-unit-tests-in-qt-creator-with-catch/">this post for the same project structure</a> using the even better Catch testing framework.</em></p>
<p>This post assumes that you are using a C++ testing framework such as UnitTest++. See <a title="Setting up UnitTest++ with Qt Creator in a nice project structure" href="http://dragly.org/2013/04/19/setting-up-unittest-with-qt-creator/">this earlier post</a> for some information on installing UnitTest++ on Ubuntu.</p>
<p>To get the most out UnitTest++ it is a good idea to integrate its output into the Qt Creator IDE. The way I have set this up in Qt Creator is with subprojects. One for the main project, which again is split into the app itself and a library, and one for the tests. In addition, I have a helper project file, named defaults.pri. The structure of the project is like this:</p>
<pre>MyProject
├─ MyProject.pro
├─ defaults.pri
├─ app/
│  ├─ app.pro
│  └─ main.cpp
├─ src/
│  ├─ src.pro
│  └─ myclass.cpp
└─ tests/
   ├─ tests.pro
   └─ main.cpp</pre>
<p>An <a href="https://github.com/ComputationalPhysics/qtcreator-project-structure">example project using this code structure</a> has been posted on Github by Filip Sund. (Thanks to Filip for doing this!)</p>
<p>The main project file, MyProject.pro will now be based on a subdirs template, and may look like this:</p>
<pre>TEMPLATE = subdirs
CONFIG+=ordered
SUBDIRS = \
    src \
    app \
    tests
app.depends = src
tests.depends = src</pre>
<p>The app.depends and tests.depends statements makes sure that the src project is compiled before the application and tests, because the src directory contains the library that will be used by both the app and the tests.</p>
<p>(<a href="http://dragly.org/2014/03/13/new-project-structure-for-projects-in-qt-creator-with-unit-tests/comment-page-1/#comment-19940">Thanks to Will</a> for noting that this works better for parallel builds with make -j 8 than my previous version only using CONFIG+=ordered. We should keep CONFIG+=ordered in there still, though, because depends doesn&#8217;t affect the order when using make install).</p>
<h2>defaults.pri</h2>
<p>Each of the other .pro files will include defaults.pri to have all the headers available. defaults.pri contains the following:</p>
<pre>INCLUDEPATH += $$PWD/src
SRC_DIR = $$PWD</pre>
<p>If the library, main program and tests use common libraries, it is very useful to have the defaults.pri define these dependencies too.</p>
<h2>./src</h2>
<p>In the src folder, I have myclass.cpp, which is the class that I want to use and test. The src.pro needs to compile to a library, so that it may be used both by app and tests, and could look something like this:</p>
<pre>include(../defaults.pri)
CONFIG -= qt

TARGET = myapp
TEMPLATE = lib

SOURCES += myclass.cpp
HEADERS += myclass.h</pre>
<p>What this class does is not so interesting, it could be anything. A simple example could be this header file:</p>
<pre class="brush:c++">#ifndef MYCLASS_H
#define MYCLASS_H

class MyClass {
public:
    double addition(double a, double b);
};

#endif // MYCLASS_H</pre>
<p>With this accompaning source file:</p>
<pre class="brush:c++">#include "myclass.h"

double MyClass::addition(double a, double b) {
    return a * b;
}</pre>
<h2>./app</h2>
<p>I only have a main.cpp file in app, because the app is basically just something that uses everything in the src folder. It will depend on the shared compiled library from src, and app.pro would look something like this:</p>
<pre>include(../defaults.pri)

TEMPLATE = app
CONFIG += console
CONFIG -= app_bundle
CONFIG -= qt

SOURCES += main.cpp

LIBS += -L../src -lmyapp</pre>
<p>The main.cpp file could be a simple program that uses MyClass:</p>
<pre class="brush:c++">#include &lt;myclass.h&gt;
#include &lt;iostream&gt;

using namespace std;

int main()
{
    MyClass adder;
    cout &lt;&lt; adder.addition(10, 20) &lt;&lt; endl;
    return 0;
}</pre>
<h2>./tests</h2>
<p>In the tests folder I have simply added a main.cpp which will run the tests. Then tests.pro has the following contents:</p>
<pre>include(../defaults.pri)
TEMPLATE = app

CONFIG   += console
CONFIG   -= app_bundle
CONFIG   -= qt

SOURCES += main.cpp

LIBS += -lunittest++ -L../src -lmyapp</pre>
<p>Which now links to the myapp library in addition to the unit tests.</p>
<p>The main.cpp in tests file which could contain the following, if we were to use UnitTest++ as our testing library:</p>
<pre class="brush:c++">#include &lt;unittest++/UnitTest++.h&gt;
#include &lt;myclass.h&gt;

TEST(MyMath) {
    MyClass my;
    CHECK(my.addition(3,4) == 7);
}

int main()
{
    return UnitTest::RunAllTests();
}</pre>
<p>This test will fail because my implementation of MyClass::addition is completely wrong:</p>
<pre class="brush:c++">class MyClass {
public:
    double addition(double a, double b) {
        return a * b;
    }
};</pre>
<p>Note that I&#8217;m including MyClass by through &lt;myclass.h&gt; which is possible because of the INCLUDEPATH variable in defaults.pri.</p>
<p>This is hopefully all you&#8217;ll need to define a project that compiles a library, as well as tests and an application using the library.</p>
]]></content:encoded>
			</item>
		<item>
		<title>Setting up UnitTest++ with Qt Creator in a nice project structure</title>
		<link>2013/04/19/setting-up-unittest-with-qt-creator/</link>
		<pubDate>Fri, 19 Apr 2013 10:07:16 +0000</pubDate>
		<dc:creator><![CDATA[Svenn-Arne Dragly]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Computational Physics]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[Qt]]></category>
		<category><![CDATA[Technical]]></category>
		<category><![CDATA[Ubuntu]]></category>
		<category><![CDATA[gui]]></category>
		<category><![CDATA[ide]]></category>
		<category><![CDATA[unit test]]></category>

		<guid isPermaLink="false">?p=404</guid>
		<description><![CDATA[Note: I&#8217;ve found a better way to visually verify that all tests are running. Check out this post on Jenkins to see how I&#8217;m now working with my tests. The below post is still useful as a reference on how to set up UnitTest++ in Qt Creator, also when using Jenkins. Note 2: A new [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><em><strong>Note</strong>: I&#8217;ve found a better way to visually verify that all tests are running. Check out <a title="Monitoring your unit tests without lifting a finger" href="http://dragly.org/2013/09/13/monitoring-your-unit-tests-without-lifting-a-finger/">this post on Jenkins</a> to see how I&#8217;m now working with my tests. The below post is still useful as a reference on how to set up UnitTest++ in Qt Creator, also when using Jenkins.</em></p>
<p><em><strong>Note 2:</strong> <del>A new and, in my opinion, better project structure is shown <a href="http://dragly.org/2014/03/13/new-project-structure-for-projects-in-qt-creator-with-unit-tests">in this new post</a>.</del></em></p>
<p><em><strong>Note 3:</strong> See <a href="http://dragly.org/2015/11/24/getting-started-with-unit-tests-in-qt-creator-with-catch/">this post for the same project structure</a> using the even better Catch testing framework.</em></p>
<p>When you want to make sure that your code is working properly, it is a good idea to divide it into smaller, independent pieces that may be tested individually. A unit test is a short  code that tests a smallest possible portion of your application. It is a good idea to write tests as you go and it can even be useful to write a test before you even implement the function that will be tested.</p>
<p>With the combination of <a href="http://unittest-cpp.sourceforge.net/UnitTest++.html">UnitTest++</a> and <a href="http://qt-project.org/downloads">Qt Creator</a>, I&#8217;m now able to write unit tests while working on the code and also have some nice visual indication about failed tests during the build step of my project:</p>
<p style="text-align: center;"><a href="http://dragly.org/wp-content/uploads/2013/04/qt-creator-unit-tests1.png" rel="lightbox[404]"><img class="aligncenter wp-image-903" src="http://dragly.org/wp-content/uploads/2013/04/qt-creator-unit-tests1.png" alt="qt-creator-unit-tests1" width="501" height="46" /></a></p>
<p>During my search for a good setup for testing my applications I realized there were a few needs that I wanted to satisfy:</p>
<ol>
<li>Creating new unit tests should be dead-easy to do. I want to spend as little time as possible on reading documentation about the testing framework.</li>
<li>Tests should be run immediately after a new build of the source code, automatically and without the extra hassle to remember to run the tests.</li>
<li>Tests should provide visual feedback with an easy way to get to where the tests fail. This should show up in the IDE or some other useful GUI tool.</li>
<li>The testing framework should be fairly easy to install, especially on Ubuntu. This is because I want to be able to promote it to my fellow students.</li>
</ol>
<p><span id="more-404"></span><br />
For a long time I have been using the QtTestlib. It is fairly quick to use, but I have failed to make the tests give me the visual feedback I wanted. In addition it requires the Qt library to run, which makes it hard to advocate to my fellow students that are not using Qt already.</p>
<h2>UnitTest++</h2>
<p>The <a href="http://unittest-cpp.sourceforge.net/UnitTest++.html">UnitTest++</a> framework is extremely simple to use. To download it in Ubuntu, all you have to do is</p>
<pre class="brush:bash">sudo apt-get install libunittest++-dev</pre>
<p>and create a new C++ file the following way:</p>
<pre class="brush:cpp">#include &lt;unittest++/UnitTest++.h&gt;

TEST(WillFail) {
    CHECK(false);
}

int main()
{
    return UnitTest::RunAllTests();
}</pre>
<p>When you compile, all you need to do is to link to the library. Add the following to your .pro file:</p>
<pre>LIBS += -lunittest++</pre>
<p>You may write as many tests as you like and check that they are successful with the CHECK macro.</p>
<p><a href="http://unittest-cpp.sourceforge.net/UnitTest++.html">Read more about the UnitTest++ library.</a></p>
<h2>The complete solution: UnitTest++ and Qt Creator</h2>
<p>To get the most out UnitTest++ it is a good idea to integrate its output into the Qt Creator IDE. The way I have set this up in Qt Creator is with subprojects. One for the main project, which again is split into the app itself and a library, and one for the tests. In addition, I have a helper project file, named defaults.pri. The structure of the project is like this:</p>
<pre>MyProject
├─ MyProject.pro
├─ defaults.pri
├─ .qmake.conf
├─ src/
│  ├─ src.pro
│  ├─ app/
│  │  ├─ app.pro
│  │  └─ main.cpp
│  └─ libs
│     ├─ libs.pro
│     └─ myclass.cpp
└─ tests/
   ├─ tests.pro
   └─ main.cpp</pre>
<p>The .qmake.conf file is a helper file that defines a few things that we will use in the subprojects. This is only available in Qt5, and looks something like this:</p>
<pre>TOP_PWD=$$PWD
TOP_OUT_PWD=$$shadowed($$PWD)</pre>
<p>The main project file, MyProject.pro will now be based on a subdirs template, and may look like this:</p>
<pre>TEMPLATE=subdirs
SUBDIRS=src tests
CONFIG+=ordered</pre>
<p>The CONFIG+=ordered statement makes sure that the src project is compiled before the tests.</p>
<p>The src.pro file looks similar:</p>
<pre>TEMPLATE=subdirs
SUBDIRS=libs app
CONFIG+=ordered</pre>
<p>The src directory contains the actual project, and is split into app and libs. In app, I now only have a main.cpp file, because the app is basically just something that uses everything in the libs folder. It will depend on the shared compiled library from libs, and app.pro would look something like this:</p>
<pre>include(../../defaults.pri)
TEMPLATE = app
SOURCES = main.cpp</pre>
<p>In the libs folder, I have myclass.cpp, that contains the MyClass class, and is what I want to test. The libs.pro needs to compile to a library, so that it may be used both by app and tests, and could look something like this:</p>
<pre>include(../../defaults.pri)
TEMPLATE = lib
TARGET = myapp
SOURCES = myclass.cpp
HEADERS = myclass.h</pre>
<p>What this class does is not so interesting, it could be anything.</p>
<p>In the tests folder I have simply added a main.cpp file which could contain the following:</p>
<pre>#include &lt;unittest++/UnitTest++.h&gt;
#include &lt;src/myclass.h&gt;

TEST(MyMath) {
    MyClass my;
    CHECK(my.addition(3,4) == 7);
}

int main()
{
    return UnitTest::RunAllTests();
}</pre>
<p>This test will fail because my implementation of MyClass::addition is completely wrong:</p>
<pre>class MyClass {
public:
    double addition(double a, double b) {
        return a * b;
    }
};</pre>
<p>Note that I&#8217;m including MyClass by through &lt;src/myclass.h&gt;. To be allowed to do this, I have included a defaults.pri file that helps me resolve the correct directory of the source files. The defaults.pri file contains this:</p>
<pre># Directories
INCLUDEPATH += $$TOP_PWD/src/libs
SRC_DIR = $$TOP_PWD</pre>
<p>And in the tests.pro file I have:</p>
<pre>include(defaults.pri)
TEMPLATE = app

CONFIG   += console
CONFIG   -= app_bundle
CONFIG   -= qt

SOURCES += main.cpp

LIBS += -lunittest++ -L$$TOP_OUT_PWD/src/libs -lmyapp</pre>
<p>The final two lines will search for any .cpp file in your source directory and add them to your test project. This may be a problem if you have source files hanging around that are not in use by your Qt project, so you may just replace these lines with all your sources explicitly.</p>
<p>If the main program uses some libraries that the test project now will also need, it is very useful to have this common defaults.pri file which may be included in both tests.pro and src.pro.</p>
<h3>Getting that visual output</h3>
<p>With the above, I&#8217;m now able to run the tests executable to get some nice terminal output:</p>
<pre class="brush:bash">../../MyProject/tests/main.cpp:72: warning: Failure in MyMath: my.addition(3,4) == 7
FAILURE: 1 out of 1 tests failed (1 failures).
Test time: 0.00 seconds.</pre>
<p>However, I would like this to show up without having to explicitly run the tests executable. To do this, I have added a Custom Build Step in Qt Creator after the Make step in MyProject.</p>
<p>Do this by selecting Projects &gt; Build Steps &gt; Add Build Step with the following options:</p>
<p style="padding-left: 30px;">Command:<strong> ./tests/tests</strong><br />
Arguments: <strong>1&gt;&amp;2</strong><br />
Working directory: <strong>%{buildDir}</strong></p>
<p>If you don&#8217;t want the tests to completely fail your build, you may replace the errors with warnings instead by using the following options instead:</p>
<p style="padding-left: 30px;">Command: <strong>./tests/tests</strong><br />
Arguments:  <strong>| sed s/error:/warning:/ 1&gt;&amp;2</strong><br />
Working directory: <strong>%{buildDir}</strong></p>
<p>It should look something like this:</p>
<p style="text-align: center;"><a href="http://dragly.org/wp-content/uploads/2013/04/qt-creator-build-step.png" rel="lightbox[404]"><img class="aligncenter wp-image-904" src="http://dragly.org/wp-content/uploads/2013/04/qt-creator-build-step.png" alt="qt-creator-build-step" width="640" height="146" /></a></p>
<p>This will invoke the command line tool sed after running the tests executable to replace all strings with &#8220;error:&#8221; to &#8220;warning:&#8221;. Qt Creator will then just list the failures in the Issues tab and start your application even if the tests fail.</p>
<h3>The best part</h3>
<p>With this up and running, you should get some output like this whenever a test fails:</p>
<p style="text-align: left;"><a href="http://dragly.org/wp-content/uploads/2013/04/qt-creator-unit-tests1.png" rel="lightbox[404]"><img class="aligncenter wp-image-903" src="http://dragly.org/wp-content/uploads/2013/04/qt-creator-unit-tests1.png" alt="qt-creator-unit-tests1" width="556" height="50" /></a>And the best thing about it is that you can even click the line to go directly to the test that fails. Isn&#8217;t that just great?</p>
<h2>Other frameworks</h2>
<p>I also came across Boost.Test and GoogleTest. The test framework from Boost seemed to be a bit too much hassle to install and the documentation was a bit outdated. It is also said that the code would build slower due to it being a header-only framework.</p>
<p>GoogleTest was likely the best alternative to UnitTest++, but installing it on Ubuntu was a bit more hassle, which made the choice easy. On the other hand, GoogleTest seems to be a more advanced framework, so I may switch sometime in the future.</p>
]]></content:encoded>
			</item>
	</channel>
</rss>
